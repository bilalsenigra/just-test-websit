<!DOCTYPE html>
<html lang="ar" dir="rtl">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>شطرنج بتصميم مبتكر</title>
    <style>
        * {
            box-sizing: border-box;
            margin: 0;
            padding: 0;
        }
        
        body {
            font-family: Arial, sans-serif;
            display: flex;
            flex-direction: column;
            align-items: center;
            background-color: #f5f5f5;
            padding: 10px;
            min-height: 100vh;
        }
        
        h1 {
            color: #333;
            margin-bottom: 15px;
            text-align: center;
            font-size: 1.5rem;
        }
        
        .game-container {
            display: flex;
            flex-direction: column;
            gap: 15px;
            width: 100%;
            max-width: 500px;
        }
        
        .board-container {
            position: relative;
            width: 100%;
            margin: 0 auto;
        }
        
        .chess-board {
            display: grid;
            grid-template-columns: repeat(8, 1fr);
            grid-template-rows: repeat(8, 1fr);
            aspect-ratio: 1 / 1;
            border: 2px solid #333;
            box-shadow: 0 0 10px rgba(0,0,0,0.3);
            position: relative;
            width: 100%;
            max-width: 500px;
        }
        
        .square {
            display: flex;
            justify-content: center;
            align-items: center;
            position: relative;
            font-size: clamp(20px, 6vw, 40px);
        }
        
        .white {
            background-color: #f0d9b5;
        }
        
        .black {
            background-color: #b58863;
        }
        
        .piece {
            width: 80%;
            height: 80%;
            display: flex;
            justify-content: center;
            align-items: center;
            cursor: pointer;
            z-index: 10;
            font-weight: bold;
            user-select: none;
            transition: transform 0.2s;
        }
        
        .piece.moving {
            transform: scale(1.1);
        }
        
        .white-piece {
            color: white;
            text-shadow: 1px 1px 2px black;
        }
        
        .black-piece {
            color: black;
            text-shadow: 1px 1px 2px white;
        }
        
        .selected {
            background-color: #aec6cf !important;
        }
        
        .valid-move {
            position: relative;
        }
        
        .valid-move::after {
            content: "";
            position: absolute;
            width: 30%;
            height: 30%;
            background-color: rgba(0, 255, 0, 0.3);
            border-radius: 50%;
            z-index: 1;
        }
        
        .capture-move::after {
            content: "";
            position: absolute;
            width: 85%;
            height: 85%;
            border: 3px solid rgba(255, 0, 0, 0.5);
            border-radius: 50%;
            z-index: 1;
        }
        
        .en-passant-move::after {
            content: "مرور";
            position: absolute;
            background-color: rgba(255, 165, 0, 0.7);
            color: white;
            font-size: clamp(8px, 2vw, 10px);
            padding: 2px 4px;
            border-radius: 3px;
            z-index: 1;
            bottom: 2px;
            left: 2px;
        }
        
        .castle-move::after {
            content: "تبييت";
            position: absolute;
            background-color: rgba(255, 165, 0, 0.7);
            color: white;
            font-size: clamp(8px, 2vw, 12px);
            padding: 2px 5px;
            border-radius: 3px;
            z-index: 1;
            bottom: 2px;
            left: 2px;
        }
        
        .check::after {
            content: "";
            position: absolute;
            width: 100%;
            height: 100%;
            background-color: rgba(255, 0, 0, 0.3);
            z-index: 1;
        }
        
        .coordinates {
            position: absolute;
            font-size: clamp(10px, 2.5vw, 14px);
            color: #333;
            pointer-events: none;
            z-index: 5;
        }
        
        .file-coordinates {
            display: flex;
            justify-content: space-around;
            bottom: -20px;
            width: 100%;
        }
        
        .rank-coordinates {
            display: flex;
            flex-direction: column;
            justify-content: space-around;
            left: -20px;
            height: 100%;
            top: 0;
        }
        
        .info-panel {
            display: flex;
            flex-direction: column;
            gap: 15px;
        }
        
        .info {
            background-color: white;
            padding: 12px;
            border-radius: 5px;
            box-shadow: 0 0 5px rgba(0,0,0,0.2);
        }
        
        .moves-history {
            background-color: white;
            padding: 12px;
            border-radius: 5px;
            box-shadow: 0 0 5px rgba(0,0,0,0.2);
            max-height: 200px;
            overflow-y: auto;
        }
        
        .moves-list {
            display: grid;
            grid-template-columns: 1fr 1fr;
            gap: 5px;
            margin-top: 10px;
        }
        
        .move-number {
            grid-column: 1 / span 2;
            font-weight: bold;
            margin-top: 5px;
            font-size: 0.9rem;
        }
        
        .move {
            padding: 4px;
            background-color: #f0f0f0;
            border-radius: 3px;
            text-align: center;
            font-size: 0.85rem;
            cursor: pointer;
            transition: background-color 0.2s;
        }
        
        .move:hover {
            background-color: #e0e0e0;
        }
        
        .move.current {
            background-color: #aec6cf;
            font-weight: bold;
        }
        
        .move.continuation {
            background-color: #d4edda;
            border: 1px solid #c3e6cb;
        }
        
        #status {
            font-weight: bold;
            margin: 8px 0;
            min-height: 20px;
            font-size: 0.9rem;
            text-align: center;
        }
        
        .controls {
            margin-top: 10px;
            display: flex;
            flex-direction: column;
            gap: 8px;
        }
        
        .control-buttons {
            display: flex;
            gap: 8px;
            flex-wrap: wrap;
        }
        
        button {
            padding: 10px 15px;
            background-color: #4CAF50;
            color: white;
            border: none;
            border-radius: 4px;
            cursor: pointer;
            font-size: 0.9rem;
            flex: 1;
            min-width: 120px;
        }
        
        button:hover {
            background-color: #45a049;
        }
        
        button.secondary {
            background-color: #6c757d;
        }
        
        button.secondary:hover {
            background-color: #5a6268;
        }
        
        .checkmate {
            color: #d32f2f;
            font-weight: bold;
        }
        
        .winner {
            color: #388e3c;
            font-weight: bold;
            font-size: 1rem;
        }
        
        .stalemate {
            color: #ff9800;
            font-weight: bold;
        }
        
        .timers {
            display: flex;
            justify-content: space-between;
            margin: 10px 0;
            gap: 10px;
        }
        
        .timer {
            background-color: #333;
            color: white;
            padding: 8px 12px;
            border-radius: 5px;
            font-family: monospace;
            font-size: 1.1rem;
            text-align: center;
            flex: 1;
        }
        
        .timer.active {
            background-color: #4CAF50;
            box-shadow: 0 0 10px rgba(76, 175, 80, 0.5);
        }
        
        .timer.low-time {
            background-color: #f44336;
            animation: pulse 1s infinite;
        }
        
        @keyframes pulse {
            0% { opacity: 1; }
            50% { opacity: 0.7; }
            100% { opacity: 1; }
        }
        
        .game-stats {
            display: flex;
            justify-content: space-around;
            margin-top: 10px;
            font-size: 0.8rem;
            color: #666;
        }
        
        .hint-move {
            background-color: rgba(255, 255, 0, 0.3) !important;
        }
        
        .settings-modal {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background-color: rgba(0, 0, 0, 0.7);
            display: flex;
            justify-content: center;
            align-items: center;
            z-index: 1000;
            padding: 20px;
        }
        
        .settings-content {
            background-color: white;
            padding: 20px;
            border-radius: 10px;
            box-shadow: 0 0 20px rgba(0, 0, 0, 0.5);
            max-width: 400px;
            width: 100%;
        }
        
        .settings-group {
            margin-bottom: 15px;
        }
        
        .settings-group label {
            display: block;
            margin-bottom: 5px;
            font-weight: bold;
        }
        
        .settings-group select, .settings-group input {
            width: 100%;
            padding: 8px;
            border: 1px solid #ddd;
            border-radius: 4px;
            font-size: 1rem;
        }
        
        .modal-buttons {
            display: flex;
            gap: 10px;
            margin-top: 20px;
        }
        
        .modal-buttons button {
            flex: 1;
        }
        
        .promotion-modal {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background-color: rgba(0, 0, 0, 0.7);
            display: flex;
            justify-content: center;
            align-items: center;
            z-index: 1000;
            padding: 20px;
        }
        
        .promotion-options {
            background-color: white;
            padding: 15px;
            border-radius: 10px;
            display: flex;
            gap: 10px;
            box-shadow: 0 0 20px rgba(0, 0, 0, 0.5);
            flex-wrap: wrap;
            justify-content: center;
        }
        
        .promotion-piece {
            font-size: clamp(30px, 8vw, 50px);
            cursor: pointer;
            padding: 8px;
            border-radius: 5px;
            transition: background-color 0.3s;
            min-width: 60px;
            text-align: center;
        }
        
        .promotion-piece:hover {
            background-color: #f0f0f0;
        }
        
        /* تحسينات للشاشات الصغيرة */
        @media (max-width: 480px) {
            .game-container {
                gap: 10px;
            }
            
            .info, .moves-history {
                padding: 10px;
            }
            
            button {
                padding: 8px 12px;
                font-size: 0.8rem;
                min-width: 100px;
            }
            
            .control-buttons {
                flex-direction: column;
            }
            
            .promotion-options {
                padding: 10px;
                gap: 8px;
            }
            
            .promotion-piece {
                min-width: 50px;
                padding: 6px;
            }
            
            .timers {
                flex-direction: column;
            }
        }
        
        @media (min-width: 768px) {
            .game-container {
                flex-direction: row;
                max-width: 900px;
            }
            
            .board-container {
                flex: 1;
            }
            
            .info-panel {
                flex: 0 0 300px;
            }
            
            .moves-history {
                max-height: 300px;
            }
        }

        /* إضافة أنماط لغة جديدة */
        .language-selector {
            position: absolute;
            top: 10px;
            left: 10px;
            z-index: 100;
        }
        
        .language-selector select {
            padding: 5px 10px;
            border-radius: 4px;
            border: 1px solid #ddd;
            background-color: white;
            font-size: 0.9rem;
        }
        
        body[dir="rtl"] {
            text-align: right;
        }
        
        body[dir="ltr"] {
            text-align: left;
        }
        
        .language-rtl {
            direction: rtl;
        }
        
        .language-ltr {
            direction: ltr;
        }
    </style>
</head>
<body>
    <div class="language-selector">
        <select id="languageSelect">
            <option value="ar">العربية</option>
            <option value="en">English</option>
            <option value="fr">Français</option>
            <option value="zh">中文</option>
            <option value="ru">Русский</option>
        </select>
    </div>
    
    <h1 id="pageTitle">لعبة شطرنج بتصميم مبتكر</h1>
    
    <div class="game-container">
        <div class="board-container">
            <div class="chess-board" id="chessBoard">
                <!-- سيتم إنشاء رقعة الشطرنج باستخدام JavaScript -->
            </div>
            <div class="coordinates file-coordinates" id="fileCoordinates"></div>
            <div class="coordinates rank-coordinates" id="rankCoordinates"></div>
        </div>
        
        <div class="info-panel">
            <div class="info">
                <p id="pieceInfo" style="font-size: 0.8rem; text-align: center; margin-bottom: 8px;">القطع البيضاء: ♔♕♖♗♘♙ | القطع السوداء: ♚♛♜♝♞♟</p>
                
                <div class="timers">
                    <div class="timer" id="whiteTimer">10:00</div>
                    <div class="timer" id="blackTimer">10:00</div>
                </div>
                
                <p id="status">اللاعب الأبيض يبدأ</p>
                
                <div class="game-stats">
                    <span id="moveCount">النقلات: 0</span>
                    <span id="fiftyMoveRule">بدون بيدق/أكل: 0</span>
                </div>
                
                <div class="controls">
                    <div class="control-buttons">
                        <button id="restartBtn">بدء لعبة جديدة</button>
                        <button id="settingsBtn" class="secondary">الإعدادات</button>
                        <button id="undoBtn" class="secondary">تراجع</button>
                        <button id="hintBtn" class="secondary">تلميح</button>
                    </div>
                    <div class="control-buttons">
                        <button id="firstMoveBtn" class="secondary">أول نقلة</button>
                        <button id="prevMoveBtn" class="secondary">نقلة سابقة</button>
                        <button id="nextMoveBtn" class="secondary">نقلة تالية</button>
                        <button id="lastMoveBtn" class="secondary">آخر نقلة</button>
                    </div>
                    <div class="control-buttons">
                        <button id="saveGameBtn" class="secondary">حفظ اللعبة</button>
                        <button id="loadGameBtn" class="secondary">تحميل اللعبة</button>
                    </div>
                </div>
            </div>
            
            <div class="moves-history">
                <h3 id="movesHistoryTitle" style="font-size: 1rem; text-align: center;">سجل النقلات</h3>
                <div class="moves-list" id="movesList">
                    <!-- سيتم عرض النقلات هنا -->
                </div>
            </div>
        </div>
    </div>

    <script>
        // إضافة كائن الترجمة
        const translations = {
            ar: {
                pageTitle: "لعبة شطرنج بتصميم مبتكر",
                pieceInfo: "القطع البيضاء: ♔♕♖♗♘♙ | القطع السوداء: ♚♛♜♝♞♟",
                whitePlayer: "الأبيض",
                blackPlayer: "أسود",
                statusStart: "اللاعب الأبيض يبدأ",
                statusTurn: "دور اللاعب",
                statusCheck: "كش!",
                statusCheckmate: "كش مات!",
                statusStalemate: "تعادل! لا توجد حركات قانونية",
                statusInsufficientMaterial: "تعادل! مواد غير كافية",
                statusKingTrapped: "تعادل! الملك محاصر ولا توجد حركات قانونية",
                statusFiftyMoveRule: "تعادل بقاعدة الخمسين نقلة",
                statusThreefoldRepetition: "تعادل بالتكرار ثلاث مرات",
                statusWhiteWins: "الأبيض فاز",
                statusBlackWins: "الأسود فاز",
                statusWhiteTimeOut: "انتهى وقت الأبيض! الأسود فاز",
                statusBlackTimeOut: "انتهى وقت الأسود! الأبيض فاز",
                movesHistoryTitle: "سجل النقلات",
                moveCount: "النقلات",
                fiftyMoveRule: "بدون بيدق/أكل",
                restartBtn: "بدء لعبة جديدة",
                settingsBtn: "الإعدادات",
                undoBtn: "تراجع",
                hintBtn: "تلميح",
                firstMoveBtn: "أول نقلة",
                prevMoveBtn: "نقلة سابقة",
                nextMoveBtn: "نقلة تالية",
                lastMoveBtn: "آخر نقلة",
                saveGameBtn: "حفظ اللعبة",
                loadGameBtn: "تحميل اللعبة",
                enPassant: "مرور",
                castling: "تبييت",
                continueFromMove: " - الاستمرار من هذه النقلة",
                gameSaved: "تم حفظ اللعبة بنجاح!",
                gameLoaded: "تم تحميل اللعبة بنجاح!",
                noSavedGame: "لا توجد لعبة محفوظة!",
                settingsTitle: "إعدادات اللعبة",
                timeControlLabel: "التحكم بالوقت (دقائق):",
                soundLabel: "الأصوات:",
                soundEnabled: "مفعلة",
                soundDisabled: "معطلة",
                saveSettings: "حفظ",
                cancelSettings: "إلغاء"
            },
            en: {
                pageTitle: "Chess Game with Innovative Design",
                pieceInfo: "White pieces: ♔♕♖♗♘♙ | Black pieces: ♚♛♜♝♞♟",
                whitePlayer: "White",
                blackPlayer: "Black",
                statusStart: "White player starts",
                statusTurn: "Turn of",
                statusCheck: "Check!",
                statusCheckmate: "Checkmate!",
                statusStalemate: "Stalemate! No legal moves",
                statusInsufficientMaterial: "Draw! Insufficient material",
                statusKingTrapped: "Draw! King is trapped with no legal moves",
                statusFiftyMoveRule: "Draw by fifty-move rule",
                statusThreefoldRepetition: "Draw by threefold repetition",
                statusWhiteWins: "White wins",
                statusBlackWins: "Black wins",
                statusWhiteTimeOut: "White time out! Black wins",
                statusBlackTimeOut: "Black time out! White wins",
                movesHistoryTitle: "Moves History",
                moveCount: "Moves",
                fiftyMoveRule: "No pawn/capture",
                restartBtn: "New Game",
                settingsBtn: "Settings",
                undoBtn: "Undo",
                hintBtn: "Hint",
                firstMoveBtn: "First Move",
                prevMoveBtn: "Previous Move",
                nextMoveBtn: "Next Move",
                lastMoveBtn: "Last Move",
                saveGameBtn: "Save Game",
                loadGameBtn: "Load Game",
                enPassant: "en passant",
                castling: "castling",
                continueFromMove: " - Continue from this move",
                gameSaved: "Game saved successfully!",
                gameLoaded: "Game loaded successfully!",
                noSavedGame: "No saved game found!",
                settingsTitle: "Game Settings",
                timeControlLabel: "Time Control (minutes):",
                soundLabel: "Sounds:",
                soundEnabled: "Enabled",
                soundDisabled: "Disabled",
                saveSettings: "Save",
                cancelSettings: "Cancel"
            },
            fr: {
                pageTitle: "Jeu d'Échecs avec Design Innovant",
                pieceInfo: "Pièces blanches: ♔♕♖♗♘♙ | Pièces noires: ♚♛♜♝♞♟",
                whitePlayer: "Blanc",
                blackPlayer: "Noir",
                statusStart: "Le joueur blanc commence",
                statusTurn: "Tour de",
                statusCheck: "Échec!",
                statusCheckmate: "Échec et mat!",
                statusStalemate: "Pat! Aucun mouvement légal",
                statusInsufficientMaterial: "Nulle! Matériel insuffisant",
                statusKingTrapped: "Nulle! Le roi est piégé sans mouvements légaux",
                statusFiftyMoveRule: "Nulle par la règle des cinquante coups",
                statusThreefoldRepetition: "Nulle par triple répétition",
                statusWhiteWins: "Les blancs gagnent",
                statusBlackWins: "Les noirs gagnent",
                statusWhiteTimeOut: "Temps écoulé pour les blancs! Les noirs gagnent",
                statusBlackTimeOut: "Temps écoulé pour les noirs! Les blancs gagnent",
                movesHistoryTitle: "Historique des Coups",
                moveCount: "Coups",
                fiftyMoveRule: "Sans pion/capture",
                restartBtn: "Nouvelle Partie",
                settingsBtn: "Paramètres",
                undoBtn: "Annuler",
                hintBtn: "Indice",
                firstMoveBtn: "Premier Coup",
                prevMoveBtn: "Coup Précédent",
                nextMoveBtn: "Coup Suivant",
                lastMoveBtn: "Dernier Coup",
                saveGameBtn: "Sauvegarder",
                loadGameBtn: "Charger",
                enPassant: "en passant",
                castling: "roque",
                continueFromMove: " - Continuer à partir de ce coup",
                gameSaved: "Partie sauvegardée avec succès!",
                gameLoaded: "Partie chargée avec succès!",
                noSavedGame: "Aucune partie sauvegardée trouvée!",
                settingsTitle: "Paramètres du Jeu",
                timeControlLabel: "Contrôle du Temps (minutes):",
                soundLabel: "Sons:",
                soundEnabled: "Activés",
                soundDisabled: "Désactivés",
                saveSettings: "Sauvegarder",
                cancelSettings: "Annuler"
            },
            zh: {
                pageTitle: "创新设计的国际象棋游戏",
                pieceInfo: "白棋: ♔♕♖♗♘♙ | 黑棋: ♚♛♜♝♞♟",
                whitePlayer: "白方",
                blackPlayer: "黑方",
                statusStart: "白方开始",
                statusTurn: "轮到",
                statusCheck: "将军!",
                statusCheckmate: "将死!",
                statusStalemate: "逼和! 无合法移动",
                statusInsufficientMaterial: "和棋! 材料不足",
                statusKingTrapped: "和棋! 王被困无合法移动",
                statusFiftyMoveRule: "五十步规则和棋",
                statusThreefoldRepetition: "三次重复和棋",
                statusWhiteWins: "白方获胜",
                statusBlackWins: "黑方获胜",
                statusWhiteTimeOut: "白方超时! 黑方获胜",
                statusBlackTimeOut: "黑方超时! 白方获胜",
                movesHistoryTitle: "移动历史",
                moveCount: "移动",
                fiftyMoveRule: "无兵/吃子",
                restartBtn: "新游戏",
                settingsBtn: "设置",
                undoBtn: "撤销",
                hintBtn: "提示",
                firstMoveBtn: "第一步",
                prevMoveBtn: "上一步",
                nextMoveBtn: "下一步",
                lastMoveBtn: "最后一步",
                saveGameBtn: "保存游戏",
                loadGameBtn: "加载游戏",
                enPassant: "吃过路兵",
                castling: "王车易位",
                continueFromMove: " - 从此移动继续",
                gameSaved: "游戏保存成功!",
                gameLoaded: "游戏加载成功!",
                noSavedGame: "未找到保存的游戏!",
                settingsTitle: "游戏设置",
                timeControlLabel: "时间控制(分钟):",
                soundLabel: "声音:",
                soundEnabled: "启用",
                soundDisabled: "禁用",
                saveSettings: "保存",
                cancelSettings: "取消"
            },
            ru: {
                pageTitle: "Шахматы с Инновационным Дизайном",
                pieceInfo: "Белые фигуры: ♔♕♖♗♘♙ | Чёрные фигуры: ♚♛♜♝♞♟",
                whitePlayer: "Белые",
                blackPlayer: "Чёрные",
                statusStart: "Белые начинают",
                statusTurn: "Ход",
                statusCheck: "Шах!",
                statusCheckmate: "Мат!",
                statusStalemate: "Пат! Нет легальных ходов",
                statusInsufficientMaterial: "Ничья! Недостаточно материала",
                statusKingTrapped: "Ничья! Король заблокирован без легальных ходов",
                statusFiftyMoveRule: "Ничья по правилу 50 ходов",
                statusThreefoldRepetition: "Ничья по трёхкратному повторению",
                statusWhiteWins: "Белые выиграли",
                statusBlackWins: "Чёрные выиграли",
                statusWhiteTimeOut: "Время белых вышло! Чёрные выиграли",
                statusBlackTimeOut: "Время чёрных вышло! Белые выиграли",
                movesHistoryTitle: "История Ходов",
                moveCount: "Ходы",
                fiftyMoveRule: "Без пешки/взятия",
                restartBtn: "Новая Игра",
                settingsBtn: "Настройки",
                undoBtn: "Отменить",
                hintBtn: "Подсказка",
                firstMoveBtn: "Первый Ход",
                prevMoveBtn: "Предыдущий Ход",
                nextMoveBtn: "Следующий Ход",
                lastMoveBtn: "Последний Ход",
                saveGameBtn: "Сохранить Игру",
                loadGameBtn: "Загрузить Игру",
                enPassant: "взятие на проходе",
                castling: "рокировка",
                continueFromMove: " - Продолжить с этого хода",
                gameSaved: "Игра успешно сохранена!",
                gameLoaded: "Игра успешно загружена!",
                noSavedGame: "Сохранённая игра не найдена!",
                settingsTitle: "Настройки Игры",
                timeControlLabel: "Контроль Времени (минуты):",
                soundLabel: "Звуки:",
                soundEnabled: "Включены",
                soundDisabled: "Выключены",
                saveSettings: "Сохранить",
                cancelSettings: "Отмена"
            }
        };

        // إنشاء رقعة الشطرنج
        const chessBoard = document.getElementById('chessBoard');
        const statusElement = document.getElementById('status');
        const movesList = document.getElementById('movesList');
        const restartBtn = document.getElementById('restartBtn');
        const settingsBtn = document.getElementById('settingsBtn');
        const undoBtn = document.getElementById('undoBtn');
        const hintBtn = document.getElementById('hintBtn');
        const firstMoveBtn = document.getElementById('firstMoveBtn');
        const prevMoveBtn = document.getElementById('prevMoveBtn');
        const nextMoveBtn = document.getElementById('nextMoveBtn');
        const lastMoveBtn = document.getElementById('lastMoveBtn');
        const saveGameBtn = document.getElementById('saveGameBtn');
        const loadGameBtn = document.getElementById('loadGameBtn');
        const whiteTimer = document.getElementById('whiteTimer');
        const blackTimer = document.getElementById('blackTimer');
        const moveCountElement = document.getElementById('moveCount');
        const fiftyMoveRuleElement = document.getElementById('fiftyMoveRule');
        const fileCoordinates = document.getElementById('fileCoordinates');
        const rankCoordinates = document.getElementById('rankCoordinates');
        const languageSelect = document.getElementById('languageSelect');
        const pageTitle = document.getElementById('pageTitle');
        const pieceInfo = document.getElementById('pieceInfo');
        const movesHistoryTitle = document.getElementById('movesHistoryTitle');
        
        // إعدادات اللعبة
        let gameSettings = {
            timeControl: 600, // 10 دقائق بالثواني
            soundEnabled: true,
            language: 'ar'
        };
        
        // تمثيل حالة اللعبة
        let boardState = [];
        let selectedPiece = null;
        let currentPlayer = 'white';
        let validMoves = [];
        let moveHistory = [];
        let boardHistory = [];
        let moveCounter = 1;
        let kingPositions = { white: { row: 7, col: 4 }, black: { row: 0, col: 4 } };
        let checkState = { white: false, black: false };
        let checkmateState = { white: false, black: false };
        let stalemateState = false;
        let insufficientMaterial = false;
        let kingTrappedState = false;
        let pendingPromotion = null;
        let castlingRights = {
            white: { kingSide: true, queenSide: true },
            black: { kingSide: true, queenSide: true }
        };
        let kingHasMoved = { white: false, black: false };
        let rookHasMoved = {
            white: { kingSide: false, queenSide: false },
            black: { kingSide: false, queenSide: false }
        };
        let currentMoveIndex = 0;
        let enPassantTarget = null;
        let fiftyMoveCounter = 0;
        let totalMoveCount = 0;
        let positionCounts = {};
        let gameTimers = {
            white: gameSettings.timeControl,
            black: gameSettings.timeControl,
            whiteTimer: null,
            blackTimer: null,
            activeTimer: null
        };

        // رموز قطع الشطرنج
        const pieceSymbols = {
            white: {
                king: '♔',
                queen: '♕',
                rook: '♖',
                bishop: '♗',
                knight: '♘',
                pawn: '♙'
            },
            black: {
                king: '♚',
                queen: '♛',
                rook: '♜',
                bishop: '♝',
                knight: '♞',
                pawn: '♟'
            }
        };

        // إحداثيات الرقعة
        const files = ['a', 'b', 'c', 'd', 'e', 'f', 'g', 'h'];
        const ranks = ['1', '2', '3', '4', '5', '6', '7', '8'];
        
        // تهيئة اللغة
        function initializeLanguage() {
            const savedLanguage = localStorage.getItem('chessLanguage');
            if (savedLanguage) {
                gameSettings.language = savedLanguage;
            }
            languageSelect.value = gameSettings.language;
            applyLanguage();
        }
        
        // تطبيق اللغة المحددة
        function applyLanguage() {
            const lang = gameSettings.language;
            const t = translations[lang];
            
            // تحديث اتجاه النص
            if (lang === 'ar') {
                document.documentElement.dir = 'rtl';
                document.body.classList.add('language-rtl');
                document.body.classList.remove('language-ltr');
            } else {
                document.documentElement.dir = 'ltr';
                document.body.classList.add('language-ltr');
                document.body.classList.remove('language-rtl');
            }
            
            // تحديث النصوص
            pageTitle.textContent = t.pageTitle;
            pieceInfo.textContent = t.pieceInfo;
            movesHistoryTitle.textContent = t.movesHistoryTitle;
            restartBtn.textContent = t.restartBtn;
            settingsBtn.textContent = t.settingsBtn;
            undoBtn.textContent = t.undoBtn;
            hintBtn.textContent = t.hintBtn;
            firstMoveBtn.textContent = t.firstMoveBtn;
            prevMoveBtn.textContent = t.prevMoveBtn;
            nextMoveBtn.textContent = t.nextMoveBtn;
            lastMoveBtn.textContent = t.lastMoveBtn;
            saveGameBtn.textContent = t.saveGameBtn;
            loadGameBtn.textContent = t.loadGameBtn;
            
            // تحديث حالة اللعبة
            updateGameStatus();
            updateGameStats();
            
            // تحديث إحداثيات الرقعة
            updateCoordinates();
            
            localStorage.setItem('chessLanguage', lang);
        }
        
        // تحديث الإحداثيات بناءً على اللغة
        function updateCoordinates() {
            fileCoordinates.innerHTML = '';
            rankCoordinates.innerHTML = '';
            
            // إضافة إحداثيات الملفات (الأعمدة)
            files.forEach(file => {
                const coord = document.createElement('div');
                coord.textContent = file;
                fileCoordinates.appendChild(coord);
            });
            
            // إضافة إحداثيات الرتب (الصفوف)
            ranks.forEach(rank => {
                const coord = document.createElement('div');
                coord.textContent = rank;
                rankCoordinates.appendChild(coord);
            });
        }
        
        // تهيئة رقعة الشطرنج
        function initializeBoard() {
            // تنظيف الرقعة
            chessBoard.innerHTML = '';
            boardState = Array(8).fill().map(() => Array(8).fill(null));
            validMoves = [];
            moveHistory = [];
            boardHistory = [];
            moveCounter = 1;
            totalMoveCount = 0;
            movesList.innerHTML = '';
            currentPlayer = 'white';
            kingPositions = { white: { row: 7, col: 4 }, black: { row: 0, col: 4 } };
            checkState = { white: false, black: false };
            checkmateState = { white: false, black: false };
            stalemateState = false;
            insufficientMaterial = false;
            kingTrappedState = false;
            pendingPromotion = null;
            enPassantTarget = null;
            fiftyMoveCounter = 0;
            positionCounts = {};
            currentMoveIndex = 0;
            
            castlingRights = {
                white: { kingSide: true, queenSide: true },
                black: { kingSide: true, queenSide: true }
            };
            kingHasMoved = { white: false, black: false };
            rookHasMoved = {
                white: { kingSide: false, queenSide: false },
                black: { kingSide: false, queenSide: false }
            };
            
            statusElement.textContent = translations[gameSettings.language].statusStart;
            statusElement.className = '';
            
            // إعادة تعيين المؤقتات
            resetTimers();
            
            // إنشاء المربعات والقطع
            for (let row = 0; row < 8; row++) {
                for (let col = 0; col < 8; col++) {
                    const square = document.createElement('div');
                    square.className = `square ${(row + col) % 2 === 0 ? 'white' : 'black'}`;
                    square.dataset.row = row;
                    square.dataset.col = col;
                    
                    // إضافة القطع في مواقعها الأولية
                    let piece = null;
                    
                    // الصف الأول (القطع السوداء)
                    if (row === 0) {
                        if (col === 0 || col === 7) piece = createPiece('rook', 'black');
                        else if (col === 1 || col === 6) piece = createPiece('knight', 'black');
                        else if (col === 2 || col === 5) piece = createPiece('bishop', 'black');
                        else if (col === 3) piece = createPiece('queen', 'black');
                        else if (col === 4) piece = createPiece('king', 'black');
                    }
                    // الصف الثاني (البيادق السوداء)
                    else if (row === 1) {
                        piece = createPiece('pawn', 'black');
                    }
                    // الصف السابع (البيادق البيضاء)
                    else if (row === 6) {
                        piece = createPiece('pawn', 'white');
                    }
                    // الصف الثامن (القطع البيضاء)
                    else if (row === 7) {
                        if (col === 0 || col === 7) piece = createPiece('rook', 'white');
                        else if (col === 1 || col === 6) piece = createPiece('knight', 'white');
                        else if (col === 2 || col === 5) piece = createPiece('bishop', 'white');
                        else if (col === 3) piece = createPiece('queen', 'white');
                        else if (col === 4) piece = createPiece('king', 'white');
                    }
                    
                    if (piece) {
                        square.appendChild(piece);
                        boardState[row][col] = {
                            type: piece.dataset.type,
                            color: piece.dataset.color
                        };
                    }
                    
                    square.addEventListener('click', handleSquareClick);
                    chessBoard.appendChild(square);
                }
            }
            
            // حفظ الحالة الأولية للوحة
            saveBoardState();
            
            updateCheckDisplay();
            updateCoordinates();
            updateGameStats();
            playSound('move');
        }
        
        // حفظ حالة الرقعة
        function saveBoardState() {
            const stateString = getBoardStateString();
            positionCounts[stateString] = (positionCounts[stateString] || 0) + 1;
            
            boardHistory.push(JSON.parse(JSON.stringify({
                board: boardState.map(row => [...row]),
                currentPlayer: currentPlayer,
                kingPositions: {...kingPositions},
                castlingRights: JSON.parse(JSON.stringify(castlingRights)),
                kingHasMoved: {...kingHasMoved},
                rookHasMoved: JSON.parse(JSON.stringify(rookHasMoved)),
                moveCounter: moveCounter,
                enPassantTarget: enPassantTarget,
                fiftyMoveCounter: fiftyMoveCounter
            })));
            currentMoveIndex = boardHistory.length - 1;
        }
        
        // الحصول على تمثيل نصي لحالة الرقعة
        function getBoardStateString() {
            let state = '';
            for (let row = 0; row < 8; row++) {
                for (let col = 0; col < 8; col++) {
                    const piece = boardState[row][col];
                    if (piece) {
                        state += piece.color === 'white' ? piece.type.charAt(0).toUpperCase() : piece.type.charAt(0).toLowerCase();
                    } else {
                        state += '-';
                    }
                }
            }
            state += currentPlayer;
            state += castlingRights.white.kingSide ? 'K' : '';
            state += castlingRights.white.queenSide ? 'Q' : '';
            state += castlingRights.black.kingSide ? 'k' : '';
            state += castlingRights.black.queenSide ? 'q' : '';
            state += enPassantTarget ? `${enPassantTarget.row},${enPassantTarget.col}` : '-';
            return state;
        }
        
        // إنشاء قطعة شطرنج
        function createPiece(type, color) {
            const piece = document.createElement('div');
            piece.className = `piece ${color}-piece`;
            piece.dataset.type = type;
            piece.dataset.color = color;
            piece.textContent = pieceSymbols[color][type];
            return piece;
        }
        
        // التعامل مع النقر على المربعات
        function handleSquareClick(event) {
            if (pendingPromotion || checkmateState.white || checkmateState.black || stalemateState || insufficientMaterial || kingTrappedState) return;
            
            const square = event.currentTarget;
            const row = parseInt(square.dataset.row);
            const col = parseInt(square.dataset.col);
            const piece = boardState[row][col];
            
            // إذا لم يكن هناك قطعة مختارة مسبقاً
            if (!selectedPiece) {
                // إذا كان هناك قطعة في المربع المختار ولونها يطابق اللاعب الحالي
                if (piece && piece.color === currentPlayer) {
                    selectedPiece = { row, col, type: piece.type, color: piece.color };
                    
                    // إبراز المربع المختار
                    square.classList.add('selected');
                    
                    // حساب الحركات المتاحة
                    validMoves = calculateValidMoves(row, col, piece.type, piece.color);
                    highlightValidMoves();
                    
                    playSound('select');
                }
            } else {
                // التحقق إذا كانت الحركة صالحة
                const moveIndex = validMoves.findIndex(move => move.row === row && move.col === col);
                
                if (moveIndex !== -1) {
                    const move = validMoves[moveIndex];
                    
                    // إذا كنا في منتصف السجل، نحذف النقلات اللاحقة
                    if (currentMoveIndex < boardHistory.length - 1) {
                        removeFutureMoves();
                    }
                    
                    // حفظ حالة اللوحة قبل الحركة
                    saveBoardState();
                    
                    // إذا كانت حركة تبييت، تنفيذ التبييت
                    if (move.castle) {
                        performCastle(currentPlayer, move.castle);
                        recordMove(selectedPiece.row, selectedPiece.col, row, col, true);
                    } 
                    // إذا كانت حركة أكل بالمرور
                    else if (move.enPassant) {
                        performEnPassant(selectedPiece.row, selectedPiece.col, row, col);
                        recordMove(selectedPiece.row, selectedPiece.col, row, col, false, true);
                    }
                    else {
                        // تحريك القطعة
                        movePiece(selectedPiece.row, selectedPiece.col, row, col);
                        
                        // تحديث حالة التبييت
                        updateCastlingRights(selectedPiece.row, selectedPiece.col, row, col);
                        
                        // تسجيل النقلة
                        recordMove(selectedPiece.row, selectedPiece.col, row, col);
                        
                        // التحقق من الترقية
                        checkForPromotion(row, col);
                    }
                    
                    // تحديث هدف الأكل بالمرور
                    updateEnPassantTarget(selectedPiece.row, selectedPiece.col, row, col);
                    
                    // تحديث عداد الخمسين نقلة
                    updateFiftyMoveCounter(selectedPiece.row, selectedPiece.col, row, col);
                    
                    // إذا لم تكن هناك ترقية معلقة، تابع اللعبة
                    if (!pendingPromotion) {
                        completeMove();
                    }
                }
                
                // إعادة تعيين القطعة المختارة
                resetSelectedPiece();
            }
        }
        
        // تحديث هدف الأكل بالمرور
        function updateEnPassantTarget(fromRow, fromCol, toRow, toCol) {
            const piece = boardState[toRow][toCol];
            
            if (piece.type === 'pawn' && Math.abs(fromRow - toRow) === 2) {
                enPassantTarget = { 
                    row: (fromRow + toRow) / 2, 
                    col: fromCol 
                };
            } else {
                enPassantTarget = null;
            }
        }
        
        // تحديث عداد الخمسين نقلة
        function updateFiftyMoveCounter(fromRow, fromCol, toRow, toCol) {
            const piece = boardState[toRow][toCol];
            const captured = boardState[toRow][toCol] !== null;
            
            if (piece.type === 'pawn' || captured) {
                fiftyMoveCounter = 0;
            } else {
                fiftyMoveCounter++;
            }
            
            updateGameStats();
            
            // التحقق من قاعدة الخمسين نقلة
            if (fiftyMoveCounter >= 50) {
                stalemateState = true;
                statusElement.textContent = translations[gameSettings.language].statusFiftyMoveRule;
                statusElement.className = 'stalemate';
                playSound('gameEnd');
            }
        }
        
        // تنفيذ الأكل بالمرور
        function performEnPassant(fromRow, fromCol, toRow, toCol) {
            const direction = currentPlayer === 'white' ? -1 : 1;
            const capturedPawnRow = fromRow;
            const capturedPawnCol = toCol;
            
            // تحريك البيدق
            movePiece(fromRow, fromCol, toRow, toCol);
            
            // إزالة البيدق المأكول
            const capturedSquare = document.querySelector(`.square[data-row="${capturedPawnRow}"][data-col="${capturedPawnCol}"]`);
            capturedSquare.innerHTML = '';
            boardState[capturedPawnRow][capturedPawnCol] = null;
            
            playSound('capture');
        }
        
        // إزالة النقلات المستقبلية عند الاستمرار من منتصف السجل
        function removeFutureMoves() {
            // إزالة النقلات من boardHistory
            boardHistory = boardHistory.slice(0, currentMoveIndex + 1);
            
            // إزالة النقلات من العرض
            const moves = document.querySelectorAll('.move, .move-number');
            const moveIndexToRemove = currentMoveIndex * 2 + 1;
            
            for (let i = moveIndexToRemove; i < moves.length; i++) {
                moves[i].remove();
            }
            
            // تحديث moveCounter
            moveCounter = Math.floor(currentMoveIndex / 2) + 1;
            
            // إعادة حساب تعداد المواقع
            positionCounts = {};
            for (let i = 0; i < boardHistory.length; i++) {
                const state = getBoardStateStringForHistory(i);
                positionCounts[state] = (positionCounts[state] || 0) + 1;
            }
        }
        
        // الحصول على تمثيل نصي لحالة الرقعة من التاريخ
        function getBoardStateStringForHistory(index) {
            const state = boardHistory[index];
            let stateString = '';
            
            for (let row = 0; row < 8; row++) {
                for (let col = 0; col < 8; col++) {
                    const piece = state.board[row][col];
                    if (piece) {
                        stateString += piece.color === 'white' ? piece.type.charAt(0).toUpperCase() : piece.type.charAt(0).toLowerCase();
                    } else {
                        stateString += '-';
                    }
                }
            }
            stateString += state.currentPlayer;
            stateString += state.castlingRights.white.kingSide ? 'K' : '';
            stateString += state.castlingRights.white.queenSide ? 'Q' : '';
            stateString += state.castlingRights.black.kingSide ? 'k' : '';
            stateString += state.castlingRights.black.queenSide ? 'q' : '';
            stateString += state.enPassantTarget ? `${state.enPassantTarget.row},${state.enPassantTarget.col}` : '-';
            return stateString;
        }
        
        // إكمال الحركة
        function completeMove() {
            totalMoveCount++;
            
            // التحقق من حالة الكش والكش مات والتعادل
            updateCheckState();
            checkForInsufficientMaterial();
            checkForKingTrapped();
            checkForStalemate();
            checkForCheckmate();
            checkForThreefoldRepetition();
            
            // تبديل اللاعب
            currentPlayer = currentPlayer === 'white' ? 'black' : 'white';
            
            // تبديل المؤقتات
            switchTimers();
            
            // تحديث حالة اللعبة
            updateGameStatus();
            
            // تحديث عرض النقلات الحالية
            updateMovesDisplay();
            
            // تحديث الإحصائيات
            updateGameStats();
            
            playSound('move');
        }
        
        // التحقق من حصار الملك (مثل الملكة في B7 تحاصر الملك)
        function checkForKingTrapped() {
            const color = currentPlayer === 'white' ? 'black' : 'white';
            const kingPos = kingPositions[color];
            
            // التحقق إذا كان الملك محاصراً بدون حركات
            const kingMoves = calculateValidMoves(kingPos.row, kingPos.col, 'king', color);
            
            if (kingMoves.length === 0 && !checkState[color]) {
                // التحقق إذا كانت هناك أي قطع أخرى يمكنها الحركة
                let hasAnyLegalMoves = false;
                
                for (let row = 0; row < 8; row++) {
                    for (let col = 0; col < 8; col++) {
                        const piece = boardState[row][col];
                        if (piece && piece.color === color && piece.type !== 'king') {
                            const moves = calculateValidMoves(row, col, piece.type, color);
                            if (moves.length > 0) {
                                hasAnyLegalMoves = true;
                                break;
                            }
                        }
                    }
                    if (hasAnyLegalMoves) break;
                }
                
                if (!hasAnyLegalMoves) {
                    kingTrappedState = true;
                    statusElement.textContent = translations[gameSettings.language].statusKingTrapped;
                    statusElement.className = 'stalemate';
                    playSound('gameEnd');
                    return;
                }
            }
            
            kingTrappedState = false;
        }
        
        // التحقق من المواد غير الكافية (التعادل)
        function checkForInsufficientMaterial() {
            let pieces = {
                white: { pawn: 0, knight: 0, bishop: 0, rook: 0, queen: 0 },
                black: { pawn: 0, knight: 0, bishop: 0, rook: 0, queen: 0 }
            };
            
            let totalPieces = 0;
            let bishops = [];
            
            for (let row = 0; row < 8; row++) {
                for (let col = 0; col < 8; col++) {
                    const piece = boardState[row][col];
                    if (piece && piece.type !== 'king') {
                        pieces[piece.color][piece.type]++;
                        totalPieces++;
                        
                        if (piece.type === 'bishop') {
                            bishops.push({
                                color: piece.color,
                                squareColor: (row + col) % 2 === 0 ? 'light' : 'dark'
                            });
                        }
                    }
                }
            }
            
            // الحالات التي تعتبر مواد غير كافية:
            
            // 1. ملك ضد ملك
            if (totalPieces === 0) {
                insufficientMaterial = true;
                return;
            }
            
            // 2. ملك وفيل ضد ملك
            if (totalPieces === 1 && (pieces.white.bishop === 1 || pieces.black.bishop === 1)) {
                insufficientMaterial = true;
                return;
            }
            
            // 3. ملك وحصان ضد ملك
            if (totalPieces === 1 && (pieces.white.knight === 1 || pieces.black.knight === 1)) {
                insufficientMaterial = true;
                return;
            }
            
            // 4. ملك وفيل ضد ملك وفيل (نفس لون المربعات)
            if (totalPieces === 2 && pieces.white.bishop === 1 && pieces.black.bishop === 1) {
                if (bishops.length === 2 && bishops[0].squareColor === bishops[1].squareColor) {
                    insufficientMaterial = true;
                    return;
                }
            }
            
            insufficientMaterial = false;
        }
        
        // التحقق من التعادل بالتكرار ثلاث مرات
        function checkForThreefoldRepetition() {
            const currentState = getBoardStateString();
            if (positionCounts[currentState] >= 3) {
                stalemateState = true;
                statusElement.textContent = translations[gameSettings.language].statusThreefoldRepetition;
                statusElement.className = 'stalemate';
                playSound('gameEnd');
            }
        }
        
        // التحقق من التعادل (حصار الملك)
        function checkForStalemate() {
            // إذا كان في كش، فلا يمكن أن يكون تعادل
            if (checkState[currentPlayer]) {
                stalemateState = false;
                return;
            }
            
            let hasLegalMoves = false;
            
            for (let row = 0; row < 8; row++) {
                for (let col = 0; col < 8; col++) {
                    const piece = boardState[row][col];
                    if (piece && piece.color === currentPlayer) {
                        const moves = calculateValidMoves(row, col, piece.type, piece.color);
                        if (moves.length > 0) {
                            hasLegalMoves = true;
                            break;
                        }
                    }
                }
                if (hasLegalMoves) break;
            }
            
            if (!hasLegalMoves) {
                stalemateState = true;
                statusElement.textContent = translations[gameSettings.language].statusStalemate;
                statusElement.className = 'stalemate';
                playSound('gameEnd');
            } else {
                stalemateState = false;
            }
        }
        
        // تحديث عرض النقلات
        function updateMovesDisplay() {
            const moves = document.querySelectorAll('.move');
            moves.forEach((move, index) => {
                move.classList.remove('current', 'continuation');
                if (index === currentMoveIndex - 1) {
                    move.classList.add('current');
                }
                else if (index >= currentMoveIndex) {
                    move.classList.add('continuation');
                }
            });
        }
        
        // الانتقال إلى نقلة محددة والاستمرار منها
        function goToMoveAndContinue(moveIndex) {
            if (moveIndex < 0 || moveIndex >= boardHistory.length) return;
            
            currentMoveIndex = moveIndex;
            
            // استعادة حالة الرقعة
            const targetState = boardHistory[moveIndex];
            
            // إعادة بناء الرقعة
            for (let row = 0; row < 8; row++) {
                for (let col = 0; col < 8; col++) {
                    const square = document.querySelector(`.square[data-row="${row}"][data-col="${col}"]`);
                    square.innerHTML = '';
                    
                    if (targetState.board[row][col]) {
                        const piece = createPiece(targetState.board[row][col].type, targetState.board[row][col].color);
                        square.appendChild(piece);
                    }
                    
                    boardState[row][col] = targetState.board[row][col];
                }
            }
            
            // استعادة جميع حالات اللعبة
            currentPlayer = targetState.currentPlayer;
            kingPositions = {...targetState.kingPositions};
            castlingRights = JSON.parse(JSON.stringify(targetState.castlingRights));
            kingHasMoved = {...targetState.kingHasMoved};
            rookHasMoved = JSON.parse(JSON.stringify(targetState.rookHasMoved));
            moveCounter = targetState.moveCounter;
            enPassantTarget = targetState.enPassantTarget;
            fiftyMoveCounter = targetState.fiftyMoveCounter;
            
            // تحديث حالة اللعبة
            updateGameStatus();
            updateCheckDisplay();
            updateMovesDisplay();
            updateGameStats();
            
            // إعادة تعيين أي قطعة مختارة
            resetSelectedPiece();
            
            statusElement.textContent += translations[gameSettings.language].continueFromMove;
            playSound('move');
        }
        
        // تحديث حالة التبييت
        function updateCastlingRights(fromRow, fromCol, toRow, toCol) {
            const piece = boardState[toRow][toCol];
            
            // إذا تحرك الملك
            if (piece.type === 'king') {
                kingHasMoved[piece.color] = true;
                castlingRights[piece.color].kingSide = false;
                castlingRights[piece.color].queenSide = false;
            }
            
            // إذا تحركت القلعة
            if (piece.type === 'rook') {
                if (piece.color === 'white') {
                    if (fromRow === 7 && fromCol === 0) {
                        rookHasMoved.white.queenSide = true;
                        castlingRights.white.queenSide = false;
                    } else if (fromRow === 7 && fromCol === 7) {
                        rookHasMoved.white.kingSide = true;
                        castlingRights.white.kingSide = false;
                    }
                } else {
                    if (fromRow === 0 && fromCol === 0) {
                        rookHasMoved.black.queenSide = true;
                        castlingRights.black.queenSide = false;
                    } else if (fromRow === 0 && fromCol === 7) {
                        rookHasMoved.black.kingSide = true;
                        castlingRights.black.kingSide = false;
                    }
                }
            }
        }
        
        // التحقق من التبييت المتاح
        function canCastle(color, side) {
            if (kingHasMoved[color]) return false;
            
            if (side === 'kingSide' && rookHasMoved[color].kingSide) return false;
            if (side === 'queenSide' && rookHasMoved[color].queenSide) return false;
            
            if (checkState[color]) return false;
            
            const kingRow = color === 'white' ? 7 : 0;
            const kingCol = 4;
            
            if (side === 'kingSide') {
                if (boardState[kingRow][5] || boardState[kingRow][6]) return false;
                if (isSquareUnderAttack(kingRow, 4, color) || 
                    isSquareUnderAttack(kingRow, 5, color) || 
                    isSquareUnderAttack(kingRow, 6, color)) return false;
            } else {
                if (boardState[kingRow][1] || boardState[kingRow][2] || boardState[kingRow][3]) return false;
                if (isSquareUnderAttack(kingRow, 2, color) || 
                    isSquareUnderAttack(kingRow, 3, color) || 
                    isSquareUnderAttack(kingRow, 4, color)) return false;
            }
            
            return true;
        }
        
        // تنفيذ التبييت
        function performCastle(color, side) {
            const kingRow = color === 'white' ? 7 : 0;
            
            if (side === 'kingSide') {
                movePiece(kingRow, 4, kingRow, 6);
                movePiece(kingRow, 7, kingRow, 5);
                kingPositions[color] = { row: kingRow, col: 6 };
            } else {
                movePiece(kingRow, 4, kingRow, 2);
                movePiece(kingRow, 0, kingRow, 3);
                kingPositions[color] = { row: kingRow, col: 2 };
            }
            
            castlingRights[color].kingSide = false;
            castlingRights[color].queenSide = false;
            kingHasMoved[color] = true;
            
            playSound('castle');
        }
        
        // التحقق من الترقية
        function checkForPromotion(row, col) {
            const piece = boardState[row][col];
            
            if (piece && piece.type === 'pawn') {
                if ((piece.color === 'white' && row === 0) || (piece.color === 'black' && row === 7)) {
                    pendingPromotion = { row, col, color: piece.color };
                    showPromotionModal(piece.color);
                }
            }
        }
        
        // عرض نافذة الترقية
        function showPromotionModal(color) {
            const modal = document.createElement('div');
            modal.className = 'promotion-modal';
            
            const options = document.createElement('div');
            options.className = 'promotion-options';
            
            const promotionPieces = ['queen', 'rook', 'bishop', 'knight'];
            
            promotionPieces.forEach(pieceType => {
                const pieceOption = document.createElement('div');
                pieceOption.className = 'promotion-piece';
                pieceOption.textContent = pieceSymbols[color][pieceType];
                pieceOption.dataset.type = pieceType;
                
                pieceOption.addEventListener('click', () => {
                    promotePawn(pieceType);
                    document.body.removeChild(modal);
                });
                
                options.appendChild(pieceOption);
            });
            
            modal.appendChild(options);
            document.body.appendChild(modal);
        }
        
        // ترقية البيدق
        function promotePawn(pieceType) {
            if (pendingPromotion) {
                const { row, col, color } = pendingPromotion;
                
                boardState[row][col] = { type: pieceType, color: color };
                
                const square = document.querySelector(`.square[data-row="${row}"][data-col="${col}"]`);
                square.innerHTML = '';
                const newPiece = createPiece(pieceType, color);
                square.appendChild(newPiece);
                
                updateCheckDisplay();
                
                const lastMoveElement = movesList.lastChild;
                if (lastMoveElement && lastMoveElement.classList.contains('move')) {
                    lastMoveElement.textContent += `=${pieceType === 'knight' ? 'N' : pieceType.toUpperCase().charAt(0)}`;
                }
                
                pendingPromotion = null;
                completeMove();
                playSound('promote');
            }
        }
        
        // حساب الحركات المتاحة
        function calculateValidMoves(row, col, type, color) {
            const moves = [];
            
            switch(type) {
                case 'pawn':
                    const direction = color === 'white' ? -1 : 1;
                    const startRow = color === 'white' ? 6 : 1;
                    
                    // حركة واحدة للأمام
                    if (isInBoard(row + direction, col) && !boardState[row + direction][col]) {
                        moves.push({row: row + direction, col: col, capture: false});
                        
                        // حركتان للأمام من الموضع الأولي
                        if (row === startRow && !boardState[row + 2*direction][col]) {
                            moves.push({row: row + 2*direction, col: col, capture: false});
                        }
                    }
                    
                    // الأكل قطرياً
                    for (let c of [col-1, col+1]) {
                        if (isInBoard(row + direction, c)) {
                            if (boardState[row + direction][c] && boardState[row + direction][c].color !== color) {
                                moves.push({row: row + direction, col: c, capture: true});
                            }
                            // الأكل بالمرور
                            else if (enPassantTarget && enPassantTarget.row === row + direction && enPassantTarget.col === c) {
                                moves.push({row: row + direction, col: c, capture: true, enPassant: true});
                            }
                        }
                    }
                    break;
                    
                case 'knight':
                    const knightMoves = [
                        {r: -2, c: -1}, {r: -2, c: 1},
                        {r: -1, c: -2}, {r: -1, c: 2},
                        {r: 1, c: -2}, {r: 1, c: 2},
                        {r: 2, c: -1}, {r: 2, c: 1}
                    ];
                    
                    for (let move of knightMoves) {
                        const newRow = row + move.r;
                        const newCol = col + move.c;
                        
                        if (isInBoard(newRow, newCol) && (!boardState[newRow][newCol] || boardState[newRow][newCol].color !== color)) {
                            moves.push({row: newRow, col: newCol, capture: !!boardState[newRow][newCol]});
                        }
                    }
                    break;
                    
                case 'bishop':
                    const bishopDirections = [
                        {r: -1, c: -1}, {r: -1, c: 1},
                        {r: 1, c: -1}, {r: 1, c: 1}
                    ];
                    
                    for (let dir of bishopDirections) {
                        for (let i = 1; i < 8; i++) {
                            const newRow = row + dir.r * i;
                            const newCol = col + dir.c * i;
                            
                            if (!isInBoard(newRow, newCol)) break;
                            
                            if (!boardState[newRow][newCol]) {
                                moves.push({row: newRow, col: newCol, capture: false});
                            } else {
                                if (boardState[newRow][newCol].color !== color) {
                                    moves.push({row: newRow, col: newCol, capture: true});
                                }
                                break;
                            }
                        }
                    }
                    break;
                    
                case 'rook':
                    const rookDirections = [
                        {r: -1, c: 0}, {r: 1, c: 0},
                        {r: 0, c: -1}, {r: 0, c: 1}
                    ];
                    
                    for (let dir of rookDirections) {
                        for (let i = 1; i < 8; i++) {
                            const newRow = row + dir.r * i;
                            const newCol = col + dir.c * i;
                            
                            if (!isInBoard(newRow, newCol)) break;
                            
                            if (!boardState[newRow][newCol]) {
                                moves.push({row: newRow, col: newCol, capture: false});
                            } else {
                                if (boardState[newRow][newCol].color !== color) {
                                    moves.push({row: newRow, col: newCol, capture: true});
                                }
                                break;
                            }
                        }
                    }
                    break;
                    
                case 'queen':
                    const queenDirections = [
                        {r: -1, c: -1}, {r: -1, c: 0}, {r: -1, c: 1},
                        {r: 0, c: -1}, {r: 0, c: 1},
                        {r: 1, c: -1}, {r: 1, c: 0}, {r: 1, c: 1}
                    ];
                    
                    for (let dir of queenDirections) {
                        for (let i = 1; i < 8; i++) {
                            const newRow = row + dir.r * i;
                            const newCol = col + dir.c * i;
                            
                            if (!isInBoard(newRow, newCol)) break;
                            
                            if (!boardState[newRow][newCol]) {
                                moves.push({row: newRow, col: newCol, capture: false});
                            } else {
                                if (boardState[newRow][newCol].color !== color) {
                                    moves.push({row: newRow, col: newCol, capture: true});
                                }
                                break;
                            }
                        }
                    }
                    break;
                    
                case 'king':
                    for (let r = -1; r <= 1; r++) {
                        for (let c = -1; c <= 1; c++) {
                            if (r === 0 && c === 0) continue;
                            
                            const newRow = row + r;
                            const newCol = col + c;
                            
                            if (isInBoard(newRow, newCol) && (!boardState[newRow][newCol] || boardState[newRow][newCol].color !== color)) {
                                moves.push({row: newRow, col: newCol, capture: !!boardState[newRow][newCol]});
                            }
                        }
                    }
                    
                    // إضافة حركات التبييت
                    if (canCastle(color, 'kingSide')) {
                        moves.push({row: row, col: 6, capture: false, castle: 'kingSide'});
                    }
                    if (canCastle(color, 'queenSide')) {
                        moves.push({row: row, col: 2, capture: false, castle: 'queenSide'});
                    }
                    break;
            }
            
            return moves.filter(move => !wouldBeInCheck(row, col, move.row, move.col, color));
        }
        
        // التحقق إذا كانت الحركة ستضع الملك في كش
        function wouldBeInCheck(fromRow, fromCol, toRow, toCol, color) {
            const originalPiece = boardState[fromRow][fromCol];
            const targetPiece = boardState[toRow][toCol];
            
            // تنفيذ الحركة مؤقتاً
            boardState[toRow][toCol] = originalPiece;
            boardState[fromRow][fromCol] = null;
            
            let kingRow = kingPositions[color].row;
            let kingCol = kingPositions[color].col;
            if (originalPiece.type === 'king') {
                kingRow = toRow;
                kingCol = toCol;
            }
            
            const inCheck = isSquareUnderAttack(kingRow, kingCol, color);
            
            // استعادة الحالة الأصلية
            boardState[fromRow][fromCol] = originalPiece;
            boardState[toRow][toCol] = targetPiece;
            
            return inCheck;
        }
        
        // التحقق إذا كان المربع تحت هجوم
        function isSquareUnderAttack(row, col, color) {
            const opponent = color === 'white' ? 'black' : 'white';
            
            for (let r = 0; r < 8; r++) {
                for (let c = 0; c < 8; c++) {
                    const piece = boardState[r][c];
                    if (piece && piece.color === opponent) {
                        const moves = calculateRawMoves(r, c, piece.type, opponent);
                        if (moves.some(move => move.row === row && move.col === col)) {
                            return true;
                        }
                    }
                }
            }
            
            return false;
        }
        
        // حساب الحركات بدون التحقق من الكش
        function calculateRawMoves(row, col, type, color) {
            const moves = [];
            
            switch(type) {
                case 'pawn':
                    const direction = color === 'white' ? -1 : 1;
                    for (let c of [col-1, col+1]) {
                        if (isInBoard(row + direction, c)) {
                            moves.push({row: row + direction, col: c, capture: true});
                        }
                    }
                    break;
                    
                case 'knight':
                    const knightMoves = [
                        {r: -2, c: -1}, {r: -2, c: 1},
                        {r: -1, c: -2}, {r: -1, c: 2},
                        {r: 1, c: -2}, {r: 1, c: 2},
                        {r: 2, c: -1}, {r: 2, c: 1}
                    ];
                    
                    for (let move of knightMoves) {
                        const newRow = row + move.r;
                        const newCol = col + move.c;
                        
                        if (isInBoard(newRow, newCol)) {
                            moves.push({row: newRow, col: newCol, capture: true});
                        }
                    }
                    break;
                    
                case 'bishop':
                    const bishopDirections = [
                        {r: -1, c: -1}, {r: -1, c: 1},
                        {r: 1, c: -1}, {r: 1, c: 1}
                    ];
                    
                    for (let dir of bishopDirections) {
                        for (let i = 1; i < 8; i++) {
                            const newRow = row + dir.r * i;
                            const newCol = col + dir.c * i;
                            
                            if (!isInBoard(newRow, newCol)) break;
                            moves.push({row: newRow, col: newCol, capture: true});
                            if (boardState[newRow][newCol]) break;
                        }
                    }
                    break;
                    
                case 'rook':
                    const rookDirections = [
                        {r: -1, c: 0}, {r: 1, c: 0},
                        {r: 0, c: -1}, {r: 0, c: 1}
                    ];
                    
                    for (let dir of rookDirections) {
                        for (let i = 1; i < 8; i++) {
                            const newRow = row + dir.r * i;
                            const newCol = col + dir.c * i;
                            
                            if (!isInBoard(newRow, newCol)) break;
                            moves.push({row: newRow, col: newCol, capture: true});
                            if (boardState[newRow][newCol]) break;
                        }
                    }
                    break;
                    
                case 'queen':
                    const queenDirections = [
                        {r: -1, c: -1}, {r: -1, c: 0}, {r: -1, c: 1},
                        {r: 0, c: -1}, {r: 0, c: 1},
                        {r: 1, c: -1}, {r: 1, c: 0}, {r: 1, c: 1}
                    ];
                    
                    for (let dir of queenDirections) {
                        for (let i = 1; i < 8; i++) {
                            const newRow = row + dir.r * i;
                            const newCol = col + dir.c * i;
                            
                            if (!isInBoard(newRow, newCol)) break;
                            moves.push({row: newRow, col: newCol, capture: true});
                            if (boardState[newRow][newCol]) break;
                        }
                    }
                    break;
                    
                case 'king':
                    for (let r = -1; r <= 1; r++) {
                        for (let c = -1; c <= 1; c++) {
                            if (r === 0 && c === 0) continue;
                            
                            const newRow = row + r;
                            const newCol = col + c;
                            
                            if (isInBoard(newRow, newCol)) {
                                moves.push({row: newRow, col: newCol, capture: true});
                            }
                        }
                    }
                    break;
            }
            
            return moves;
        }
        
        // التحقق إذا كان المربع داخل الرقعة
        function isInBoard(row, col) {
            return row >= 0 && row < 8 && col >= 0 && col < 8;
        }
        
        // إبراز الحركات المتاحة
        function highlightValidMoves() {
            document.querySelectorAll('.valid-move, .capture-move, .castle-move, .en-passant-move').forEach(el => {
                el.classList.remove('valid-move', 'capture-move', 'castle-move', 'en-passant-move');
            });
            
            validMoves.forEach(move => {
                const square = document.querySelector(`.square[data-row="${move.row}"][data-col="${move.col}"]`);
                if (square) {
                    if (move.castle) {
                        square.classList.add('castle-move');
                        // تحديث نص التبييت بناءً على اللغة
                        const t = translations[gameSettings.language];
                        square.querySelector('.castle-move::after').textContent = t.castling;
                    } else if (move.enPassant) {
                        square.classList.add('en-passant-move');
                        // تحديث نص الأكل بالمرور بناءً على اللغة
                        const t = translations[gameSettings.language];
                        square.querySelector('.en-passant-move::after').textContent = t.enPassant;
                    } else if (move.capture) {
                        square.classList.add('capture-move');
                    } else {
                        square.classList.add('valid-move');
                    }
                }
            });
        }
        
        // إبراز حركة تلميحية
        function showHint() {
            if (currentMoveIndex < boardHistory.length - 1) return; // لا تظهر تلميحات في منتصف السجل
            
            const hint = findBestHint();
            if (hint) {
                document.querySelectorAll('.hint-move').forEach(el => {
                    el.classList.remove('hint-move');
                });
                
                const fromSquare = document.querySelector(`.square[data-row="${hint.from.row}"][data-col="${hint.from.col}"]`);
                const toSquare = document.querySelector(`.square[data-row="${hint.to.row}"][data-col="${hint.to.col}"]`);
                
                if (fromSquare) fromSquare.classList.add('hint-move');
                if (toSquare) toSquare.classList.add('hint-move');
                
                playSound('hint');
            }
        }
        
        // إيجاد أفضل حركة تلميحية (مبسطة)
        function findBestHint() {
            const moves = [];
            
            for (let row = 0; row < 8; row++) {
                for (let col = 0; col < 8; col++) {
                    const piece = boardState[row][col];
                    if (piece && piece.color === currentPlayer) {
                        const pieceMoves = calculateValidMoves(row, col, piece.type, piece.color);
                        pieceMoves.forEach(move => {
                            // تقييم مبسط للحركات
                            let score = 0;
                            
                            // الأكل يعطي نقاط أكثر للقطع الأقوى
                            if (move.capture) {
                                const targetPiece = boardState[move.row][move.col];
                                if (targetPiece) {
                                    const pieceValues = { pawn: 1, knight: 3, bishop: 3, rook: 5, queen: 9, king: 0 };
                                    score += pieceValues[targetPiece.type] * 10;
                                }
                            }
                            
                            // الحركات التي تهدد الملك تعطي نقاط إضافية
                            if (wouldBeInCheck(row, col, move.row, move.col, currentPlayer === 'white' ? 'black' : 'white')) {
                                score += 5;
                            }
                            
                            // التبييت جيد
                            if (move.castle) {
                                score += 3;
                            }
                            
                            moves.push({
                                from: { row, col },
                                to: { row: move.row, col: move.col },
                                score: score
                            });
                        });
                    }
                }
            }
            
            if (moves.length === 0) return null;
            
            // ترتيب الحركات حسب النقاط
            moves.sort((a, b) => b.score - a.score);
            return moves[0];
        }
        
        // تحديث حالة الكش
        function updateCheckState() {
            checkState.white = isSquareUnderAttack(kingPositions.white.row, kingPositions.white.col, 'white');
            checkState.black = isSquareUnderAttack(kingPositions.black.row, kingPositions.black.col, 'black');
            updateCheckDisplay();
        }
        
        // التحقق من الكش مات
        function checkForCheckmate() {
            const color = currentPlayer === 'white' ? 'black' : 'white';
            
            if (!checkState[color]) {
                checkmateState[color] = false;
                return;
            }
            
            for (let row = 0; row < 8; row++) {
                for (let col = 0; col < 8; col++) {
                    const piece = boardState[row][col];
                    if (piece && piece.color === color) {
                        const moves = calculateValidMoves(row, col, piece.type, piece.color);
                        if (moves.length > 0) {
                            checkmateState[color] = false;
                            return;
                        }
                    }
                }
            }
            
            checkmateState[color] = true;
            playSound('gameEnd');
        }
        
        // تحديث عرض حالة الكش
        function updateCheckDisplay() {
            document.querySelectorAll('.check').forEach(el => {
                el.classList.remove('check');
            });
            
            if (checkState.white) {
                const kingSquare = document.querySelector(`.square[data-row="${kingPositions.white.row}"][data-col="${kingPositions.white.col}"]`);
                if (kingSquare) kingSquare.classList.add('check');
            }
            
            if (checkState.black) {
                const kingSquare = document.querySelector(`.square[data-row="${kingPositions.black.row}"][data-col="${kingPositions.black.col}"]`);
                if (kingSquare) kingSquare.classList.add('check');
            }
        }
        
        // تحديث حالة اللعبة
        function updateGameStatus() {
            const t = translations[gameSettings.language];
            
            if (checkmateState.white) {
                statusElement.textContent = `${t.statusCheckmate} ${t.statusBlackWins}`;
                statusElement.className = 'winner';
                stopTimers();
            } else if (checkmateState.black) {
                statusElement.textContent = `${t.statusCheckmate} ${t.statusWhiteWins}`;
                statusElement.className = 'winner';
                stopTimers();
            } else if (stalemateState) {
                statusElement.textContent = t.statusStalemate;
                statusElement.className = 'stalemate';
                stopTimers();
            } else if (insufficientMaterial) {
                statusElement.textContent = t.statusInsufficientMaterial;
                statusElement.className = 'stalemate';
                stopTimers();
            } else if (kingTrappedState) {
                statusElement.textContent = t.statusKingTrapped;
                statusElement.className = 'stalemate';
                stopTimers();
            } else if (checkState[currentPlayer]) {
                const playerName = currentPlayer === 'white' ? t.whitePlayer : t.blackPlayer;
                statusElement.textContent = `${t.statusTurn} ${playerName} - ${t.statusCheck}`;
                statusElement.className = 'checkmate';
            } else {
                const playerName = currentPlayer === 'white' ? t.whitePlayer : t.blackPlayer;
                statusElement.textContent = `${t.statusTurn} ${playerName}`;
                statusElement.className = '';
            }
        }
        
        // تحديث إحصائيات اللعبة
        function updateGameStats() {
            const t = translations[gameSettings.language];
            moveCountElement.textContent = `${t.moveCount}: ${totalMoveCount}`;
            fiftyMoveRuleElement.textContent = `${t.fiftyMoveRule}: ${fiftyMoveCounter}`;
        }
        
        // إعادة تعيين القطعة المختارة
        function resetSelectedPiece() {
            if (selectedPiece) {
                const prevSquare = document.querySelector(`.square[data-row="${selectedPiece.row}"][data-col="${selectedPiece.col}"]`);
                if (prevSquare) prevSquare.classList.remove('selected');
                selectedPiece = null;
                validMoves = [];
                
                document.querySelectorAll('.valid-move, .capture-move, .castle-move, .en-passant-move, .hint-move').forEach(el => {
                    el.classList.remove('valid-move', 'capture-move', 'castle-move', 'en-passant-move', 'hint-move');
                });
            }
        }
        
        // تحريك القطعة
        function movePiece(fromRow, fromCol, toRow, toCol) {
            const fromSquare = document.querySelector(`.square[data-row="${fromRow}"][data-col="${fromCol}"]`);
            const toSquare = document.querySelector(`.square[data-row="${toRow}"][data-col="${toCol}"]`);
            
            if (!fromSquare || !toSquare) {
                console.error('المربع غير موجود');
                return;
            }
            
            // إذا كانت هناك قطعة في المربع الهدف، إزالتها (أكلها)
            if (boardState[toRow][toCol]) {
                toSquare.innerHTML = '';
                playSound('capture');
            } else {
                playSound('move');
            }
            
            // نقل القطعة
            const piece = fromSquare.querySelector('.piece');
            if (!piece) {
                console.error('القطعة غير موجودة في المربع المصدر');
                return;
            }
            
            // إضافة تأثير الحركة
            piece.classList.add('moving');
            
            setTimeout(() => {
                toSquare.appendChild(piece);
                piece.classList.remove('moving');
            }, 100);
            
            // تحديث موقع الملك إذا لزم الأمر
            if (boardState[fromRow][fromCol].type === 'king') {
                kingPositions[boardState[fromRow][fromCol].color] = { row: toRow, col: toCol };
            }
            
            // تحديث حالة الرقعة
            boardState[toRow][toCol] = boardState[fromRow][fromCol];
            boardState[fromRow][fromCol] = null;
        }
        
        // تسجيل النقلة
        function recordMove(fromRow, fromCol, toRow, toCol, isCastle = false, isEnPassant = false) {
            const piece = boardState[toRow][toCol];
            const captured = isEnPassant ? 'pawn' : (boardState[toRow][toCol] ? boardState[toRow][toCol].type : null);
            
            const columns = ['a', 'b', 'c', 'd', 'e', 'f', 'g', 'h'];
            const fromNotation = `${columns[fromCol]}${8-fromRow}`;
            const toNotation = `${columns[toCol]}${8-toRow}`;
            let moveText = '';
            
            if (isCastle) {
                if (toCol === 6) {
                    moveText = 'O-O';
                } else {
                    moveText = 'O-O-O';
                }
            } else {
                if (piece.type !== 'pawn') {
                    moveText = piece.type === 'knight' ? 'N' : 
                              piece.type === 'bishop' ? 'B' : 
                              piece.type === 'rook' ? 'R' : 
                              piece.type === 'queen' ? 'Q' : 'K';
                }
                
                if (captured) {
                    if (piece.type === 'pawn') {
                        moveText += columns[fromCol] + 'x';
                    } else {
                        moveText += 'x';
                    }
                }
                moveText += toNotation;
                
                if (isEnPassant) {
                    moveText += ' e.p.';
                }
                
                const nextPlayer = currentPlayer === 'white' ? 'black' : 'white';
                if (isSquareUnderAttack(kingPositions[nextPlayer].row, kingPositions[nextPlayer].col, nextPlayer)) {
                    moveText += '+';
                }
            }
            
            // إنشاء عنصر النقلة مع إضافة حدث النقر
            if (currentPlayer === 'white') {
                const moveElement = document.createElement('div');
                moveElement.className = 'move-number';
                moveElement.textContent = `${moveCounter}.`;
                movesList.appendChild(moveElement);
                
                const whiteMove = document.createElement('div');
                whiteMove.className = 'move';
                whiteMove.textContent = moveText;
                whiteMove.dataset.moveIndex = boardHistory.length - 1;
                whiteMove.addEventListener('click', () => goToMoveAndContinue(parseInt(whiteMove.dataset.moveIndex)));
                movesList.appendChild(whiteMove);
                
                moveHistory.push({white: moveText});
            } else {
                const blackMove = document.createElement('div');
                blackMove.className = 'move';
                blackMove.textContent = moveText;
                blackMove.dataset.moveIndex = boardHistory.length - 1;
                blackMove.addEventListener('click', () => goToMoveAndContinue(parseInt(blackMove.dataset.moveIndex)));
                movesList.appendChild(blackMove);
                
                moveHistory[moveHistory.length-1].black = moveText;
                moveCounter++;
            }
            
            movesList.scrollTop = movesList.scrollHeight;
            
            return moveText;
        }
        
        // المؤقتات
        function resetTimers() {
            gameTimers.white = gameSettings.timeControl;
            gameTimers.black = gameSettings.timeControl;
            updateTimerDisplay();
            
            whiteTimer.classList.remove('active', 'low-time');
            blackTimer.classList.remove('active', 'low-time');
            whiteTimer.classList.add('active');
            
            stopTimers();
        }
        
        function updateTimerDisplay() {
            whiteTimer.textContent = formatTime(gameTimers.white);
            blackTimer.textContent = formatTime(gameTimers.black);
            
            // تحذير عندما يقل الوقت عن 30 ثانية
            if (gameTimers.white <= 30) whiteTimer.classList.add('low-time');
            if (gameTimers.black <= 30) blackTimer.classList.add('low-time');
        }
        
        function formatTime(seconds) {
            const mins = Math.floor(seconds / 60);
            const secs = seconds % 60;
            return `${mins}:${secs < 10 ? '0' : ''}${secs}`;
        }
        
        function startTimers() {
            stopTimers();
            gameTimers.activeTimer = setInterval(() => {
                if (currentPlayer === 'white') {
                    gameTimers.white--;
                    if (gameTimers.white <= 0) {
                        gameTimers.white = 0;
                        statusElement.textContent = translations[gameSettings.language].statusWhiteTimeOut;
                        statusElement.className = 'winner';
                        stopTimers();
                        playSound('gameEnd');
                        return;
                    }
                } else {
                    gameTimers.black--;
                    if (gameTimers.black <= 0) {
                        gameTimers.black = 0;
                        statusElement.textContent = translations[gameSettings.language].statusBlackTimeOut;
                        statusElement.className = 'winner';
                        stopTimers();
                        playSound('gameEnd');
                        return;
                    }
                }
                updateTimerDisplay();
            }, 1000);
        }
        
        function stopTimers() {
            if (gameTimers.activeTimer) {
                clearInterval(gameTimers.activeTimer);
                gameTimers.activeTimer = null;
            }
        }
        
        function switchTimers() {
            whiteTimer.classList.toggle('active');
            blackTimer.classList.toggle('active');
            startTimers();
        }
        
        // الأصوات
        function playSound(type) {
            if (!gameSettings.soundEnabled) return;
            
            try {
                const audioContext = new (window.AudioContext || window.webkitAudioContext)();
                const oscillator = audioContext.createOscillator();
                const gainNode = audioContext.createGain();
                
                oscillator.connect(gainNode);
                gainNode.connect(audioContext.destination);
                
                let frequency = 440;
                let duration = 0.1;
                
                switch(type) {
                    case 'move':
                        frequency = 523; // C5
                        break;
                    case 'capture':
                        frequency = 659; // E5
                        break;
                    case 'check':
                        frequency = 784; // G5
                        duration = 0.3;
                        break;
                    case 'castle':
                        frequency = 392; // G4
                        break;
                    case 'promote':
                        frequency = 1047; // C6
                        break;
                    case 'gameEnd':
                        frequency = 330; // E4
                        duration = 0.5;
                        break;
                    case 'select':
                        frequency = 494; // B4
                        duration = 0.05;
                        break;
                    case 'hint':
                        frequency = 880; // A5
                        duration = 0.2;
                        break;
                }
                
                oscillator.frequency.setValueAtTime(frequency, audioContext.currentTime);
                gainNode.gain.setValueAtTime(0.3, audioContext.currentTime);
                gainNode.gain.exponentialRampToValueAtTime(0.01, audioContext.currentTime + duration);
                
                oscillator.start(audioContext.currentTime);
                oscillator.stop(audioContext.currentTime + duration);
            } catch (e) {
                console.log('الأصوات غير مدعومة في هذا المتصفح');
            }
        }
        
        // حفظ وتحمل اللعبة
        function saveGame() {
            const gameData = {
                boardHistory: boardHistory,
                moveHistory: moveHistory,
                currentMoveIndex: currentMoveIndex,
                moveCounter: moveCounter,
                totalMoveCount: totalMoveCount,
                fiftyMoveCounter: fiftyMoveCounter,
                positionCounts: positionCounts,
                timers: gameTimers,
                settings: gameSettings
            };
            
            localStorage.setItem('chessGame', JSON.stringify(gameData));
            alert(translations[gameSettings.language].gameSaved);
        }
        
        function loadGame() {
            const savedGame = localStorage.getItem('chessGame');
            if (savedGame) {
                const gameData = JSON.parse(savedGame);
                
                boardHistory = gameData.boardHistory;
                moveHistory = gameData.moveHistory;
                currentMoveIndex = gameData.currentMoveIndex;
                moveCounter = gameData.moveCounter;
                totalMoveCount = gameData.totalMoveCount;
                fiftyMoveCounter = gameData.fiftyMoveCounter;
                positionCounts = gameData.positionCounts;
                gameTimers = gameData.timers;
                if (gameData.settings) gameSettings = gameData.settings;
                
                goToMoveAndContinue(currentMoveIndex);
                updateTimerDisplay();
                alert(translations[gameSettings.language].gameLoaded);
            } else {
                alert(translations[gameSettings.language].noSavedGame);
            }
        }
        
        // التراجع عن النقلة
        function undoMove() {
            if (currentMoveIndex > 0) {
                goToMoveAndContinue(currentMoveIndex - 1);
                playSound('move');
            }
        }
        
        // إعدادات اللعبة
        function showSettings() {
            const modal = document.createElement('div');
            modal.className = 'settings-modal';
            
            const content = document.createElement('div');
            content.className = 'settings-content';
            
            const t = translations[gameSettings.language];
            
            content.innerHTML = `
                <h3 style="text-align: center; margin-bottom: 20px;">${t.settingsTitle}</h3>
                
                <div class="settings-group">
                    <label>${t.timeControlLabel}</label>
                    <select id="timeControl">
                        <option value="300">5 ${gameSettings.language === 'ar' ? 'دقائق' : 'minutes'}</option>
                        <option value="600" selected>10 ${gameSettings.language === 'ar' ? 'دقائق' : 'minutes'}</option>
                        <option value="900">15 ${gameSettings.language === 'ar' ? 'دقائق' : 'minutes'}</option>
                        <option value="1200">20 ${gameSettings.language === 'ar' ? 'دقائق' : 'minutes'}</option>
                        <option value="1500">25 ${gameSettings.language === 'ar' ? 'دقائق' : 'minutes'}</option>
                    </select>
                </div>
                
                <div class="settings-group">
                    <label>${t.soundLabel}</label>
                    <select id="soundEnabled">
                        <option value="true">${t.soundEnabled}</option>
                        <option value="false">${t.soundDisabled}</option>
                    </select>
                </div>
                
                <div class="modal-buttons">
                    <button id="saveSettings" style="background-color: #4CAF50;">${t.saveSettings}</button>
                    <button id="cancelSettings" class="secondary">${t.cancelSettings}</button>
                </div>
            `;
            
            // تعيين القيم الحالية
            content.querySelector('#timeControl').value = gameSettings.timeControl;
            content.querySelector('#soundEnabled').value = gameSettings.soundEnabled;
            
            content.querySelector('#saveSettings').addEventListener('click', () => {
                gameSettings.timeControl = parseInt(content.querySelector('#timeControl').value);
                gameSettings.soundEnabled = content.querySelector('#soundEnabled').value === 'true';
                
                document.body.removeChild(modal);
                resetTimers();
            });
            
            content.querySelector('#cancelSettings').addEventListener('click', () => {
                document.body.removeChild(modal);
            });
            
            modal.appendChild(content);
            document.body.appendChild(modal);
        }
        
        // معالجات الأحداث للأزرار
        restartBtn.addEventListener('click', initializeBoard);
        settingsBtn.addEventListener('click', showSettings);
        undoBtn.addEventListener('click', undoMove);
        hintBtn.addEventListener('click', showHint);
        firstMoveBtn.addEventListener('click', () => goToMoveAndContinue(0));
        prevMoveBtn.addEventListener('click', () => goToMoveAndContinue(Math.max(0, currentMoveIndex - 1)));
        nextMoveBtn.addEventListener('click', () => goToMoveAndContinue(Math.min(boardHistory.length - 1, currentMoveIndex + 1)));
        lastMoveBtn.addEventListener('click', () => goToMoveAndContinue(boardHistory.length - 1));
        saveGameBtn.addEventListener('click', saveGame);
        loadGameBtn.addEventListener('click', loadGame);
        
        // معالج حدث تغيير اللغة
        languageSelect.addEventListener('change', function() {
            gameSettings.language = this.value;
            applyLanguage();
        });
        
        // بدء اللعبة
        initializeLanguage();
        initializeBoard();
        startTimers();
    </script>
</body>
</html>
